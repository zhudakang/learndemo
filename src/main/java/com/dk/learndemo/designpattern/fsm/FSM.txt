FSM 有限状态机
Finite State Machine
状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。
事件也称为转移条件（Transition Condition）。

我之前实现的状态模式是通过枚举类型来实现的。


我们的订单的生命周期lifecycle其实就是一种状态机的模式。
比如提交，订单的状态就会变成提交的枚举类型。


状态机实现方式一：分支逻辑法对于如何实现状态机。
其中，最简单直接的实现方式是，参照状态转移图。编写代码会包含大量的 if-else 或 switch-case 分支判断逻辑

这种简单地话还好，如果是很复杂的，那么状态机修改就很容易出bug。

状态机实现方式二：
使用二维数组进行状态定义，比较清晰，修改配置文件即可。
比如这样的二维数组。
private static final State[][] transitionTable =
{ {SUPER, CAPE, FIRE, SMALL}, {SUPER, CAPE, FIRE, SMALL}, {CAPE, CAPE, CAPE, SMALL}, {FIRE, FIRE, FIRE, SMALL} };

private static final int[][] actionTable = { {+100, +200, +300, +0}, {+0, +200, +300, -100}, {+0, +0, +0, -200}, {+0, +0, +0, -300} };

马里奥状态对应的分数这样。

状态机实现方式三：状态模式
一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能发送消息通知等等），
我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的实现方式有一定局限性。

真实的业务场景也是很复杂的，都是状态机的不同的接口的转变。
虽然分支逻辑的实现方式不存在这个问题，但它又存在前面讲到的其他问题，比如分支判断逻辑较多，
导致代码可读性和可维护性不好等。实际上，针对分支逻辑法存在的问题，我们可以使用状态模式来解决。



