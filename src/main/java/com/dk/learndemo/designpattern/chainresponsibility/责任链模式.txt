使用场景：
在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。
例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，
但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、
电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。

其实就是一个链式传递问题。

在计算机软硬件中也有相关例子，如总线网中数据报传送，每台计算机根据目标地址是否同自己的地址相同来决定是否接收；
还有异常处理中，处理程序根据异常的类型决定自己是否处理该异常；还有 Struts2 的拦截器、JSP 和 Servlet 的 Filter 等，
所有这些，如果用责任链模式都能很好解决。

比如异常的controller的捕获也算是责任链模式吧？从上到下的捕获异常，定义各种异常的类型，最后是exception的通用捕获~
拦截器的注册应该也算这种，可以定义拦截器的注册顺序，然后链式的处理~

模式的定义和特点：
为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；
当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止

注意：责任链模式也叫职责链模式。

这种模式客户只需要把请求发送到责任链中，然后不需要关注处理的细节和传递过程(如果不是一个链式的结构，可能需要将请求发送到各处，
而这样就只需要发送一次让它链式的处理去就好了~)

优点总结：
1.降低了对象的耦合度,对象不需要知道是哪个对象处理请求和链式的结构
2.可以动态的调整新增删除责任
3.简化了对象之间的连接，每个对象只需要保持一个指向其后继者的引用。
不需要保持其他所有的处理者的引用
4. 责任分担，每一个类只需要处理自己该处理的工作。不该处理的传递下一个对象完成。明确各类责任范围，符合单一职责原则。

缺点：
不能保证每个请求一定被处理。因为如果一个请求没有明确的接收者，所以不一定能保证他被处理，可能一直到责任链的底部也没有处理它。
较长的责任链，系统性能可能受到影响。
责任链建立的合理性，需要靠客户端来保证，这家客户端的复杂性。

数据结构：
通常情况下，可以通过数据链表来实现职责链模式的数据结构。
1. 模式的结构
职责链模式主要包含以下角色。
抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。


